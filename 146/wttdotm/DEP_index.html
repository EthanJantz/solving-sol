<html>
  <head>
    <meta>

      <title>Solving Sol</title>
      <!-- Load latest acron version first -->
      <script type="text/javascript" src="https://unpkg.com/acorn"></script>
      <!-- Then load Paper.js -->
      <script type="text/javascript" src="https://unpkg.com/paper"></script>
      <!-- <script type="text/javascript" src="http://cdnjs.cloudflare.com/ajax/libs/paper.js/0.9.18/paper-full.min.js" ></script> -->
      <style type="text/css">

        html, body {
          width: 100%;
          height: 100%;
          overflow: hidden;
          padding: 0;
          margin: 0;
        }

        canvas[resize] {
            width: 100%;
            height: 100%;
        }

      </style>
    </meta>
  </head>
  <body>
    <script canvas='solving-sol' type='text/paperscript'>

      /*

        PASTE SOL INSTRUCTIONS HERE i.e...

        Solving Sol #50A

        A wall divided into four parts by lines drawn corner to corner. 
        Each section with three different colors made of parallel lines superimposed. 
        Color pencil.

        Reference: https://www.themodern.org/sites/default/files/being_there_art_assignment_4_final.pdf

      */

      function onResize() {
        // Handle resizes
        // Paper.js will call this handler automatically on resize.

        //this plus the removeChildren() at the start of init is very hacky but works
        init()
      }


      function init() {
        //this is a very
        project.activeLayer.removeChildren()
        console.log(view)
       

        

// Wall Drawing #146
// All two-part combinations of blue arcs from corners and sides, 
// and blue straight, not straight, and broken lines.

//first I am going to randomly make + position all of the squares
//then I am going to find out what has the longest continuous line
//then I am going to find out what has the longest continuous line that does not use any of those squares
//then once more
//then I am going to draw the third longest
//then random ones
//then the second longest
//then the first one

//8 possible arcs
//12 possible lines
//96 total squares


let inchInPx = 96
let dimensions = {x : 12, y : 8}
let time = 0


// let square = {
//     line : {
//         direction : "", //vertical, horizontal, upDiag, downDiag
//         type : "" // 
//     },
//     arc : {
//         center: "", //UL, RR, BR, BL, etc. tells us the center, which is all we need for an arc
//     },
//     id : 0, //gets assigned after shuffle
//     upperRightCorner: //also assigned after shuffle, lets us know where to make the square
//     arcConnectionPoints : []
//      allConnectionPoints : [[]] // arr of coords where lines end, also assigned after shuffle
// }



let arcs = ["UL", "UU", "UR", "RR", "BR", "BB", "BL", "LL"]
let lines = ["vertical", "horizontal", "upDiag", "downDiag"]
let lineTypes = ["straight", "wavy", "broken"]

let initialArray = []

//make the initial array
for (let i = 0; i < arcs.length; i++) {
    for (let j = 0; j < lines.length; j++) {
        for (let k = 0; k < lineTypes.length; k++) {
            let square = {
                line : {
                    direction : lines[j], //vertical, horizontal, upDiag, downDiag
                    type : lineTypes[k] // 
                },
                arc : {
                    center: arcs[i], //UL, RR, BR, BL, etc. tells us the center, which is all we need for an arc
                },
                id : 0, //gets assigned after shuffle
                upperLeftCorner: [],//also assigned after shuffle, lets us know where to make the square
                arcConnectionPoints : [],
                lineConnectionPoints : [],
                allConnectionPoints : [] // arr of coords where lines end, also assigned after shuffle
            }
            initialArray.push(square)
        }
    }
}

// console.log(initialArray)

//shuffle the initial array
//stole this function
const shuffle = (array) => { 
  for (let i = array.length - 1; i > 0; i--) { 
    const j = Math.floor(Math.random() * (i + 1)); 
    [array[i], array[j]] = [array[j], array[i]]; 
  } 
  return array; 
}; 

const newArr = shuffle(initialArray)
newArr.forEach(function(el) {console.log(el.arc.center)})

function findArcConnectionPoints (upperLeftCorner, arcCenter) {
    if (arcCenter == "UL" || arcCenter == "BR") return [[upperLeftCorner[0] + inchInPx, upperLeftCorner[1]], [upperLeftCorner[0], upperLeftCorner[1]+inchInPx]]
    // else if (arcCenter == "BR") return [[upperLeftCorner[0] + inchInPx, upperLeftCorner[1]], [upperLeftCorner[0], upperLeftCorner[1]+inchInPx]
    else if (arcCenter ==  "UR" || arcCenter == "BL") return [[upperLeftCorner[0], upperLeftCorner[1]], [upperLeftCorner[0] + inchInPx, upperLeftCorner[1] + inchInPx]]
    // else if (arcCenter ==  "BL") return [[upperLeftCorner[0], upperLeftCorner[1]], [upperLeftCorner[0] + inchInPx, upperLeftCorner[1] + inchInPx]]
    else if (arcCenter == "UU" || arcCenter == "BB") return [[upperLeftCorner[0], upperLeftCorner[1] + (inchInPx/2)], [upperLeftCorner[0] + inchInPx, upperLeftCorner[1] + (inchInPx/2)]]
    // else if (arcCenter == "BB") return [[upperLeftCorner[0], upperLeftCorner[1] + (inchInPx/2)], [upperLeftCorner[0] + inchInPx, upperLeftCorner[1] + (inchInPx/2)]
    else if (arcCenter == "LL" || arcCenter == "RR") return [[upperLeftCorner[0] + (inchInPx/2), upperLeftCorner[1]], [upperLeftCorner[0] + (inchInPx/2), upperLeftCorner[1] + inchInPx]]
}

function findLineConnectionPoints (upperLeftCorner, direction) {
    if (direction == "vertical") return [[upperLeftCorner[0] + (inchInPx/2), upperLeftCorner[1]], [[upperLeftCorner[0] + (inchInPx/2), upperLeftCorner[1] + inchInPx]]]
    else if (direction == "horizontal") return [[upperLeftCorner[0], upperLeftCorner[1] + (inchInPx/2)], [upperLeftCorner[0] + inchInPx, upperLeftCorner[1] + (inchInPx/2)]]
    else if (direction == "upDiag") return [[upperLeftCorner[0] + inchInPx, upperLeftCorner[1]], [upperLeftCorner[0], upperLeftCorner[1]+inchInPx]]
    else if (direction == "downDiag") return [[upperLeftCorner[0], upperLeftCorner[1]], [upperLeftCorner[0] + inchInPx, upperLeftCorner[1] + inchInPx]]
}

let arrIndex = 0
for (let i = 0; i < dimensions.y; i++) {
    for (let j = 0; j < dimensions.x; j++) {
        let upperLeftCorner = [j * inchInPx, i * inchInPx]
        let arcConnectionPoints = findArcConnectionPoints(upperLeftCorner, newArr[arrIndex].arc.center)
        let lineConnectionPoints = findLineConnectionPoints(upperLeftCorner, newArr[arrIndex].line.direction)
        newArr[arrIndex].id = arrIndex;
        newArr[arrIndex].upperLeftCorner = upperLeftCorner
        newArr[arrIndex].arcConnectionPoints = arcConnectionPoints
        newArr[arrIndex].lineConnectionPoints = lineConnectionPoints
        newArr[arrIndex].allConnectionPoints = [...arcConnectionPoints, ...lineConnectionPoints]
        console.log(newArr[arrIndex])
        arrIndex++
    }
}


// for (let i = 0; i < newArr.length; i++) {
//     drawSquare()
// }


// newArr.forEach(function (el) {console.log("allConnectionPoints", el.allConnectionPoints)})
// // function makeAnyFunctionOverSpecificTime([])

function makeSineWave () {
    var path = new Path()
    path.strokeColor = "black"
    view.onFrame = function (event) {
        time++
        // path.add(new Point(time, (Math.sin(time/10)*5+40)));
        path.add(new Point((Math.sin(time/4)*5+50), time))
    }
}
makeSineWave()

function getRandomInt(max) {
  return Math.floor(Math.random() * max) + 1;
}


// makeRightAngle([100,100], [300, 300], "left")

function drawMovingLine(startingXY, endingXY, color, time) {
    console.log("in moving line", startingXY, endingXY)
    var path = new Path.Line({
        from: [startingXY[0], startingXY[1]],
        to: [startingXY[0], startingXY[1]],
        strokeColor: color,
        strokeWidth : 2
    });
    
    console.log(path.segments[1])
    // path.dashArray = [10, 4];
    path.tween({
        'segments[1].point': {x: endingXY[0], y: endingXY[1] },
    }, time);
}

function drawDiagonalLeftBlueLine (square, time) {
    console.log("this is square .segments", square.segments, [square.segments[0].point.x, square.segments[0].point.y], [square.segments[3].point.x, square.segments[3].point.y])
    let coords = [[square.segments[1].point.x, square.segments[1].point.y], [square.segments[3].point.x, square.segments[3].point.y]]
    if (getRandomInt(2)<2) drawMovingLine(coords[0], coords[1], "blue", time)
    else drawMovingLine(coords[1], coords[0], "blue", time)
}

function drawDiagonalRightRedLine (square, time) {
    console.log("in draw diag right")
    let coords = [[square.segments[0].point.x, square.segments[0].point.y], [square.segments[2].point.x, square.segments[2].point.y]]
    if (getRandomInt(2)<2) drawMovingLine(coords[0], coords[1], "red", time)
    else drawMovingLine(coords[1], coords[0], "red", time)
}

function drawVerticalBlackLine (square, time) {
    let horizontalX = (square.segments[1].point.x + square.segments[2].point.x)/2
    let coords = [[
        horizontalX, 
        square.segments[1].point.y], 
        [horizontalX, 
        square.segments[3].point.y]]
    if (getRandomInt(2)<2) drawMovingLine(coords[0], coords[1], "#black", time)
    else drawMovingLine(coords[1], coords[0], "black", time)
}

function drawHorizontalYellowLine (square, time) {
    let verticalY = (square.segments[0].point.y + square.segments[1].point.y) / 2
    let coords = [[
            square.segments[0].point.x, 
            verticalY], 
            [square.segments[3].point.x, 
            verticalY]]
    console.log("vertY", verticalY)
    // this could be a ternary but more readable this way
    if (getRandomInt(2)<2) drawMovingLine(coords[0], coords[1], "#FDDA0D", time)    
    else drawMovingLine(coords[1], coords[0], "#FDDA0D", time)

    
}

drawMovingLine([0, inchInPx], [400, inchInPx], "green", 5000)

function drawSquare(upperLeftXY, color, time) {
    console.log("in drawSquare", upperLeftXY)
    var rectangle = new Rectangle(new Point(...upperLeftXY), new Point(upperLeftXY[0] + inchInPx, upperLeftXY[1] + inchInPx));
    var path = new Path.Rectangle(rectangle);
    path.strokeColor = color;
    path.strokeWidth = 2
    
    // return {time, square : path}
}

function drawLines(square) {
        // console.log("this is time", this.time)
        let time = 1000
        let lineMade = false
        while (!lineMade) {
            console.log("in while", getRandomInt(4))
            console.log("HELLOOOOOOOOOOOOO")
            if (getRandomInt(4) === 1) {
                drawVerticalBlackLine(square, time)
                lineMade = true
            }
            if (getRandomInt(4) === 2) {
                drawHorizontalYellowLine(square, time)
                lineMade = true
            }
            if (getRandomInt(4) === 3) {
                drawDiagonalRightRedLine(square, time)
                lineMade = true
            }
            if (getRandomInt(4) === 4) {
                drawDiagonalLeftBlueLine(square, time)
                lineMade = true
            }
        }
    }





function newDrawSquare (square) {
    var rectangle = new Rectangle(new Point(square.upperLeftCorner), new Point(square.upperLeftCorner[0] + inchInPx, square.upperLeftCorner[1] + inchInPx));
    var path = new Path.Rectangle(rectangle);
    path.strokeColor = "red";
    path.strokeWidth = 2
    
    //Make Lines
    if (square.line.type == "wavy") {
        
    } else {
        var line = new Path.Line(new Point(...square.lineConnectionPoints[0]), new Point(square.lineConnectionPoints[1]))
        line.strokeColor = "green"
        line.strokeWidth = 3
        if (square.line.type == "broken") line.dashArray = [10, 4];
        //if (square.line.type == "wavy") line
    }
}


for (let i = 0; i < newArr.length; i++) {
    console.log("in for loop", newArr[i].upperLeftCorner)
    // console.log(newArr[i].lineConnectionPoints)
    newDrawSquare(newArr[i])
}
      }

      // This will fire when Paper.js is ready
      init();

    </script>

    <canvas id='solving-sol' resize>
      <!-- Paperscript will draw the graphics here -->
    </canvas>

  </body>
</html>



////



// Wall Drawing #146
// All two-part combinations of blue arcs from corners and sides, 
// and blue straight, not straight, and broken lines.

//first I am going to randomly make + position all of the squares
//then I am going to find out what has the longest continuous line
//then I am going to find out what has the longest continuous line that does not use any of those squares
//then once more
//then I am going to draw the third longest
//then random ones
//then the second longest
//then the first one

//8 possible arcs
//12 possible lines
//96 total squares


let inchInPx = 96
let dimensions = {x : 12, y : 8}
let time = 0


// let square = {
//     line : {
//         direction : "", //vertical, horizontal, upDiag, downDiag
//         type : "" // 
//     },
//     arc : {
//         center: "", //UL, RR, BR, BL, etc. tells us the center, which is all we need for an arc
//     },
//     id : 0, //gets assigned after shuffle
//     upperRightCorner: //also assigned after shuffle, lets us know where to make the square
//     arcConnectionPoints : []
//      allConnectionPoints : [[]] // arr of coords where lines end, also assigned after shuffle
// }



let arcs = ["UL", "UU", "UR", "RR", "BR", "BB", "BL", "LL"]
let lines = ["vertical", "horizontal", "upDiag", "downDiag"]
let lineTypes = ["straight", "wavy", "broken"]

let initialArray = []

//make the initial array
for (let i = 0; i < arcs.length; i++) {
    for (let j = 0; j < lines.length; j++) {
        for (let k = 0; k < lineTypes.length; k++) {
            let square = {
                line : {
                    direction : lines[j], //vertical, horizontal, upDiag, downDiag
                    type : lineTypes[k] // 
                },
                arc : {
                    center: arcs[i], //UL, RR, BR, BL, etc. tells us the center, which is all we need for an arc
                },
                id : 0, //gets assigned after shuffle
                upperLeftCorner: [],//also assigned after shuffle, lets us know where to make the square
                arcConnectionPoints : [],
                lineConnectionPoints : [],
                allConnectionPoints : [] // arr of coords where lines end, also assigned after shuffle
            }
            initialArray.push(square)
        }
    }
}

// console.log(initialArray)

//shuffle the initial array
//stole this function
const shuffle = (array) => { 
  for (let i = array.length - 1; i > 0; i--) { 
    const j = Math.floor(Math.random() * (i + 1)); 
    [array[i], array[j]] = [array[j], array[i]]; 
  } 
  return array; 
}; 

const newArr = shuffle(initialArray)
newArr.forEach(function(el) {console.log(el.arc.center)})

function findArcConnectionPoints (upperLeftCorner, arcCenter) {
    if (arcCenter == "UL" || arcCenter == "BR") return [[upperLeftCorner[0] + inchInPx, upperLeftCorner[1]], [upperLeftCorner[0], upperLeftCorner[1]+inchInPx]]
    // else if (arcCenter == "BR") return [[upperLeftCorner[0] + inchInPx, upperLeftCorner[1]], [upperLeftCorner[0], upperLeftCorner[1]+inchInPx]
    else if (arcCenter ==  "UR" || arcCenter == "BL") return [[upperLeftCorner[0], upperLeftCorner[1]], [upperLeftCorner[0] + inchInPx, upperLeftCorner[1] + inchInPx]]
    // else if (arcCenter ==  "BL") return [[upperLeftCorner[0], upperLeftCorner[1]], [upperLeftCorner[0] + inchInPx, upperLeftCorner[1] + inchInPx]]
    else if (arcCenter == "UU" || arcCenter == "BB") return [[upperLeftCorner[0], upperLeftCorner[1] + (inchInPx/2)], [upperLeftCorner[0] + inchInPx, upperLeftCorner[1] + (inchInPx/2)]]
    // else if (arcCenter == "BB") return [[upperLeftCorner[0], upperLeftCorner[1] + (inchInPx/2)], [upperLeftCorner[0] + inchInPx, upperLeftCorner[1] + (inchInPx/2)]
    else if (arcCenter == "LL" || arcCenter == "RR") return [[upperLeftCorner[0] + (inchInPx/2), upperLeftCorner[1]], [upperLeftCorner[0] + (inchInPx/2), upperLeftCorner[1] + inchInPx]]
}

function findLineConnectionPoints (upperLeftCorner, direction) {
    if (direction == "vertical") return [[upperLeftCorner[0] + (inchInPx/2), upperLeftCorner[1]], [[upperLeftCorner[0] + (inchInPx/2), upperLeftCorner[1] + inchInPx]]]
    else if (direction == "horizontal") return [[upperLeftCorner[0], upperLeftCorner[1] + (inchInPx/2)], [upperLeftCorner[0] + inchInPx, upperLeftCorner[1] + (inchInPx/2)]]
    else if (direction == "upDiag") return [[upperLeftCorner[0] + inchInPx, upperLeftCorner[1]], [upperLeftCorner[0], upperLeftCorner[1]+inchInPx]]
    else if (direction == "downDiag") return [[upperLeftCorner[0], upperLeftCorner[1]], [upperLeftCorner[0] + inchInPx, upperLeftCorner[1] + inchInPx]]
}

let arrIndex = 0
for (let i = 0; i < dimensions.y; i++) {
    for (let j = 0; j < dimensions.x; j++) {
        let upperLeftCorner = [j * inchInPx, i * inchInPx]
        let arcConnectionPoints = findArcConnectionPoints(upperLeftCorner, newArr[arrIndex].arc.center)
        let lineConnectionPoints = findLineConnectionPoints(upperLeftCorner, newArr[arrIndex].line.direction)
        newArr[arrIndex].id = arrIndex;
        newArr[arrIndex].upperLeftCorner = upperLeftCorner
        newArr[arrIndex].arcConnectionPoints = arcConnectionPoints
        newArr[arrIndex].lineConnectionPoints = lineConnectionPoints
        newArr[arrIndex].allConnectionPoints = [...arcConnectionPoints, ...lineConnectionPoints]
        console.log(newArr[arrIndex])
        arrIndex++
    }
}


// for (let i = 0; i < newArr.length; i++) {
//     drawSquare()
// }


// newArr.forEach(function (el) {console.log("allConnectionPoints", el.allConnectionPoints)})
// // function makeAnyFunctionOverSpecificTime([])

function makeSineWave () {
    var path = new Path()
    path.strokeColor = "black"
    // path.rotation = 45
    view.onFrame = function (event) {
        time++
        // path.add(new Point(time, (Math.sin(time/10)*5+40)));
        path.add(new Point((Math.sin(time/4)*5+50), time))
        if ((time) === 150) console.log(path.rotation)
    }
}
makeSineWave()

function makeCoordSineWave (square) {
    console.log("in make sine", square.lineConnectionPoints, square.line.direction)
    let direction = square.line.direction 
    let startingCoords = square.lineConnectionPoints[0]
    let endingCoords = square.lineConnectionPoints[1]
    var path = new Path()
    path.strokeColor = "black"
    console.log("start, end", startingCoords, endingCoords)
    view.onFrame = function (event) {
        console.log("in time loop")
        time++
        if (direction === "vertical") path.add(new Point((Math.sin(time/4)*5 + startingCoords[0]), startingCoords[1] + time))
        if (direction === "horizontal") path.add(new Point(startingCoords[0] + time, (Math.sin(time/10)*5 + startingCoords[1])))
        // path.add(new Point(time, (Math.sin(time/10)*5+40)));
    }
}

function getRandomInt(max) {
  return Math.floor(Math.random() * max) + 1;
}


// makeRightAngle([100,100], [300, 300], "left")

function drawMovingLine(startingXY, endingXY, color, time, broken = false) {
    console.log("in moving line", startingXY, endingXY)
    var path = new Path.Line({
        from: [startingXY[0], startingXY[1]],
        to: [startingXY[0], startingXY[1]],
        strokeColor: color,
        strokeWidth : 2
    });
    if (broken) path.dashArray = [10, 4]
    
    console.log(path.segments[1])
    // path.dashArray = [10, 4];
    path.tween({
        'segments[1].point': {x: endingXY[0], y: endingXY[1] },
    }, time);
}

// function drawArc (square) {
//     var from = new Point(, 20);
//     var through = new Point(50, 20);
//     var to = new Point(80, 80);
//     var path = new Path.Arc(from, through, to);
//     path.strokeColor = 'black';
// }




function newDrawSquare (square) {
    var rectangle = new Rectangle(new Point(square.upperLeftCorner), new Point(square.upperLeftCorner[0] + inchInPx, square.upperLeftCorner[1] + inchInPx));
    var path = new Path.Rectangle(rectangle);
    path.strokeColor = "red";
    path.strokeWidth = 2
    makeCoordSineWave(square)
    //Make Lines
    if (square.line.type == "wavy") {
        
    } else {
        drawMovingLine(square.lineConnectionPoints[0], square.lineConnectionPoints[1], "blue", 1000, square.line.type === "broken")
        // var line = new Path.Line(new Point(...square.lineConnectionPoints[0]), new Point(square.lineConnectionPoints[1]))
        // line.strokeColor = "green"
        // line.strokeWidth = 3
        // if (square.line.type == "broken") line.dashArray = [10, 4];
        //if (square.line.type == "wavy") line
    }
}


for (let i = 0; i < newArr.length; i++) {
    console.log("in for loop", newArr[i].upperLeftCorner)
    // console.log(newArr[i].lineConnectionPoints)
    newDrawSquare(newArr[i])
}



//i is x, j is y
//row loop
// for (let i = 0; i < 200; i+= inchInPx) {
//     for (let j = 0; j < 200; j += inchInPx) {
//         let newSquare = drawSquare([i,j], [i + inchInPx, j+inchInPx], "black")
//         drawLines(newSquare)
//     }
// }
// let newSquare = drawSquare([0,0], [96, 96], "black")
// drawLines(newSquare)




//SCRATCH
    //test
        // function makeRightAngle(from, to, direction) {
        //     //taking a line as a diagonal through a square, calcualte the corners
        //     console.log("in make right angle")
            
        //     var path = new Path.Line({
        //         from: [from[0],from[1]],
        //         to: [to[0],to[1]],
        //         opacity: 0,
        //     });
        //     path.rotate(90)
            
        //     let leftCorner = path.segments[0].point
        //     let rightCorner = path.segments[1].point
            
        //     //now we make lines fom the FROM to the LEFT OR RIGHT CORNER to the TO
        //     let corner;
        //     if (direction === "left") corner = leftCorner
        //     else corner = rightCorner
        //     var firstPath = new Path.Line({
        //         from: [from[0],from[1]],
        //         to: [corner.x,corner.y],
        //         opacity: 1,
        //         strokeColor: "black",
        //         strokeWidth : 2
        //     });
        //     var secondPath = new Path.Line({
        //         from: [corner.x,corner.y],
        //         to: [to[0],to[1]],
        //         opacity: 1,
        //         strokeColor: "black",
        //         strokeWidth : 2
        //     });
            
        //     console.log(path.segments)
        //     return path
        // }
        
        
        
        
        // // function drawMovingCurve(startingXY, endingXY, color, time) {
        
        // function drawMovingCurve() {
        //     // console.log("in moving curve", startingXY, endingXY)
            
        //     var handleIn = new Point(-80, -100);
        //     var handleOut = new Point(80, 100);
            
        
            
        //     var firstPoint = new Point(150, 200);
        //     var firstSegment = new Segment(firstPoint, null, handleOut);
            
        //     var secondPoint = new Point(150, 400);
        //     var secondSegment = new Segment(secondPoint, handleIn, null);
            
        //     var handlePaths = new Path(handleIn, handleOut)
        //     handlePaths.strokeColor = "green"
        //     var points = new Path(firstPoint, secondPoint)
        //     points.strokeColor = "red"
            
        //     var path = new Path(firstSegment, secondSegment);
        //     path.strokeColor = 'black';
            
        //     console.log(path.segments[1])
        //     // path.dashArray = [10, 4];
        //     path.tween({
        //         'segments[1].point': { x: 300, y: 50 },
        //         'segments[1].handleIn' : { x: -80, y: -100 }
        //     }, time);
        // }
        // // drawMovingCurve()
        
        // function makeJaggedLine() {
        //     console.log("in jagged")
            
        //     var path = new Path.Line({
        //         from: [0,0],
        //         to: [400,400],
        //         strokeColor: "black",
        //         strokeWidth : 2,
        //         opacity : 0
        //     });
        //     console.log(path.segments)
        //     return path
        // }
        
        // makeJaggedLine()
        // let rotatedAngle = makeJaggedLine().rotate(90)
        // rotatedAngle.opacity = 1
        // console.log(rotatedAngle.segments)





        // Wall Drawing #146
        // All two-part combinations of blue arcs from corners and sides, 
        // and blue straight, not straight, and broken lines.
        
        //first I am going to randomly make + position all of the squares
        //then I am going to find out what has the longest continuous line
        //then I am going to find out what has the longest continuous line that does not use any of those squares
        //then once more
        //then I am going to draw the third longest
        //then random ones
        //then the second longest
        //then the first one
        
        //8 possible arcs
        //12 possible lines
        //96 total squares
        
        //1 frame is 1/100s
        
        let inchInPx = 96
        let dimensions = {x : 3, y : 3}
        let time = 0
        // function onFrame(event) {
        //     if (event.time > 5) console.log(time)
        //     else {
        //         time++
        //     // console.log(event.time)
        //     }
        // }
        function setIntervalX(callback, delay, repetitions) {
            var x = 0;
            var intervalID = window.setInterval(function () {
        
               callback();
        
               if (++x === repetitions) {
                   window.clearInterval(intervalID);
               }
            }, delay);
        }
        
        // let square = {
        //     line : {
        //         direction : "", //vertical, horizontal, upDiag, downDiag
        //         type : "" // 
        //     },
        //     arc : {
        //         center: "", //UL, RR, BR, BL, etc. tells us the center, which is all we need for an arc
        //     },
        //     id : 0, //gets assigned after shuffle
        //     upperRightCorner: //also assigned after shuffle, lets us know where to make the square
        //     arcConnectionPoints : []
        //      allConnectionPoints : [[]] // arr of coords where lines end, also assigned after shuffle
        // }
        
        
        
        let arcs = ["UL", "UU", "UR", "RR", "BR", "BB", "BL", "LL"]
        let lines = ["vertical", "horizontal", "upDiag", "downDiag"]
        let lineTypes = ["straight", "wavy", "broken"]
        
        let initialArray = []
        
        //make the initial array
        for (let i = 0; i < arcs.length; i++) {
            for (let j = 0; j < lines.length; j++) {
                for (let k = 0; k < lineTypes.length; k++) {
                    let square = {
                        line : {
                            direction : lines[j], //vertical, horizontal, upDiag, downDiag
                            type : lineTypes[k] // 
                        },
                        arc : {
                            center: arcs[i], //UL, RR, BR, BL, etc. tells us the center, which is all we need for an arc
                        },
                        id : 0, //gets assigned after shuffle
                        upperLeftCorner: [],//also assigned after shuffle, lets us know where to make the square
                        arcConnectionPoints : [],
                        lineConnectionPoints : [],
                        allConnectionPoints : [], // arr of coords where lines end, also assigned after shuffle
                        order : 0
                    }
                    initialArray.push(square)
                }
            }
        }
        
        // console.log(initialArray)
        
        //shuffle the initial array
        //stole this function
        const shuffle = (array) => { 
          for (let i = array.length - 1; i > 0; i--) { 
            const j = Math.floor(Math.random() * (i + 1)); 
            [array[i], array[j]] = [array[j], array[i]]; 
          } 
          return array; 
        }; 
        
        const newArr = shuffle(initialArray)
        // newArr.forEach(function(el) {console.log(el.arc.center)})
        
        function findArcConnectionPoints (upperLeftCorner, arcCenter) {
            if (arcCenter == "UL" || arcCenter == "BR") return [[upperLeftCorner[0] + inchInPx, upperLeftCorner[1]], [upperLeftCorner[0], upperLeftCorner[1]+inchInPx]]
            // else if (arcCenter == "BR") return [[upperLeftCorner[0] + inchInPx, upperLeftCorner[1]], [upperLeftCorner[0], upperLeftCorner[1]+inchInPx]
            else if (arcCenter ==  "UR" || arcCenter == "BL") return [[upperLeftCorner[0], upperLeftCorner[1]], [upperLeftCorner[0] + inchInPx, upperLeftCorner[1] + inchInPx]]
            // else if (arcCenter ==  "BL") return [[upperLeftCorner[0], upperLeftCorner[1]], [upperLeftCorner[0] + inchInPx, upperLeftCorner[1] + inchInPx]]
            else if (arcCenter == "UU" || arcCenter == "BB") return [[upperLeftCorner[0], upperLeftCorner[1] + (inchInPx/2)], [upperLeftCorner[0] + inchInPx, upperLeftCorner[1] + (inchInPx/2)]]
            // else if (arcCenter == "BB") return [[upperLeftCorner[0], upperLeftCorner[1] + (inchInPx/2)], [upperLeftCorner[0] + inchInPx, upperLeftCorner[1] + (inchInPx/2)]
            else if (arcCenter == "LL" || arcCenter == "RR") return [[upperLeftCorner[0] + (inchInPx/2), upperLeftCorner[1]], [upperLeftCorner[0] + (inchInPx/2), upperLeftCorner[1] + inchInPx]]
        }
        
        function findLineConnectionPoints (upperLeftCorner, direction) {
            if (direction == "vertical") return [[upperLeftCorner[0] + (inchInPx/2), upperLeftCorner[1]], [[upperLeftCorner[0] + (inchInPx/2), upperLeftCorner[1] + inchInPx]]]
            else if (direction == "horizontal") return [[upperLeftCorner[0], upperLeftCorner[1] + (inchInPx/2)], [upperLeftCorner[0] + inchInPx, upperLeftCorner[1] + (inchInPx/2)]]
            else if (direction == "upDiag") return [[upperLeftCorner[0] + inchInPx, upperLeftCorner[1]], [upperLeftCorner[0], upperLeftCorner[1]+inchInPx]]
            else if (direction == "downDiag") return [[upperLeftCorner[0], upperLeftCorner[1]], [upperLeftCorner[0] + inchInPx, upperLeftCorner[1] + inchInPx]]
        }
        
        let arrIndex = 0
        for (let i = 0; i < dimensions.y; i++) {
            for (let j = 0; j < dimensions.x; j++) {
                let upperLeftCorner = [j * inchInPx, i * inchInPx]
                let arcConnectionPoints = findArcConnectionPoints(upperLeftCorner, newArr[arrIndex].arc.center)
                let lineConnectionPoints = findLineConnectionPoints(upperLeftCorner, newArr[arrIndex].line.direction)
                newArr[arrIndex].id = arrIndex;
                newArr[arrIndex].upperLeftCorner = upperLeftCorner
                newArr[arrIndex].arcConnectionPoints = arcConnectionPoints
                newArr[arrIndex].lineConnectionPoints = lineConnectionPoints
                newArr[arrIndex].allConnectionPoints = [...arcConnectionPoints, ...lineConnectionPoints]
                // console.log(newArr[arrIndex])
                arrIndex++
            }
        }
        
        
        // for (let i = 0; i < newArr.length; i++) {
        //     drawSquare()
        // }
        
        
        // newArr.forEach(function (el) {console.log("allConnectionPoints", el.allConnectionPoints)})
        // // function makeAnyFunctionOverSpecificTime([])
        
        function makeSineWave () {
            var path = new Path()
            path.strokeColor = "green"
            // path.rotation = 45
            let done = false
            let newPath
            let direction = "downDiag"
            view.onFrame = function (event) {
                if (event.time > 1 && !done) {
                    done = true
                } else if (!done) {
                    if (newPath) newPath.remove()
                    time++
                    let zeroZero = new Point(0,0)
                    let point = new Point((Math.sin(time/4)*3+(inchInPx)), inchInPx * (time) )
                    // console.log("point before rotate", point)
                    point.rotate(45, zeroZero)
                    // console.log("point after rotate ", point)
                    // path.add(new Point(time, (Math.sin(time/10)*5+40)));
                    // console.log("this is path rotation:", path.rotation)
                    path.add(point)
                    newPath = path.clone()
                    newPath.strokeWidth = 4
                    newPath.strokeColor = "red"
                    newPath.rotate(45, new Point(inchInPx,0))
                    // if (path.rotation !== 45) path.rotation = 45
                    // path.rotate(45, zeroZero)
                    // if ((time) === 150) console.log(path.rotation)
                    
                }
            }
        }
        
        function makeSineWaveNew (startCoords, endCoords, direction, order = 0) {
            //make initial path
            var path = new Path()
            path.strokeWidth = 4
            path.strokeColor = "green"
            let done 
            view.onFrame = function (event) {
                //horizontal case
                
                if (direction === "horizontal" && event.time * 100 < inchInPx) {
                    console.log("in onframe in horizontal")
                    if (event.time * 100 < inchInPx) {
                        path.add(new Point(event.time*100, (Math.sin(event.time*100/4)*4+startCoords[1])));
                    }
                } else if (direction === "vertical" && event.time * 100 < inchInPx) {
                    console.log("in onframe in horizontal")
                    if (event.time * 100 < inchInPx) {
                        path.add(new Point((Math.sin(event.time*100/4)*4+startCoords[0]), event.time*100));
                    }
                }
                
                //vertical case
                
                
                //diag case
                let done = false
            }
        }
        // makeSineWave()
        // makeSineWaveNew([0, 48], [96, 48], "horizontal")
        makeSineWaveNew([48, 0], [48, 96], "vertical")
        
        var aFrom = new Point( 0, 0 );
        var center = new Point( 0, 300 );
        var arc;
        function makeArc() {
            let done = false
            view.onFrame = function (event) {
                console.log("in on frame", (event.time % 1))
              if ( arc && !done ) {
                  arc.remove();
                }
                
              var through = aFrom.clone().rotate( ( 180 * (event.time % 1) / 4 ), center);
                var to = aFrom.clone().rotate( ( 180 * (event.time % 1 / 2) ), center);
                arc = new Path.Arc( aFrom, through, to );
                arc.strokeColor = 'black';
                if (event.time % 1 > 0.98) done = true
                }
            }
            
        
        
        // makeArc()
        
        
        function makeCoordSineWave (square) {
            console.log("in make sine", square.lineConnectionPoints, square.line.direction)
            let direction = square.line.direction 
            let startingCoords = square.lineConnectionPoints[0]
            let endingCoords = square.lineConnectionPoints[1]
        
            var path = new Path()
            path.strokeColor = "black"
            path.strokeWidth = 10
            console.log("start, end", startingCoords, endingCoords)
            let setInterval 
        }
        
        function getRandomInt(max) {
          return Math.floor(Math.random() * max) + 1;
        }
        
        
        // makeRightAngle([100,100], [300, 300], "left")
        
        function drawMovingLine(startingXY, endingXY, color, time, broken = false) {
            // console.log("in moving line", startingXY, endingXY)
            var path = new Path.Line({
                from: [startingXY[0], startingXY[1]],
                to: [startingXY[0], startingXY[1]],
                strokeColor: color,
                strokeWidth : 2
            });
            if (broken) path.dashArray = [10, 4]
            
            // console.log(path.segments[1])
            // path.dashArray = [10, 4];
            path.tween({
                'segments[1].point': {x: endingXY[0], y: endingXY[1] },
            }, time);
        }
        
        
        
        
        function newDrawSquare (square) {
            var rectangle = new Rectangle(new Point(square.upperLeftCorner), new Point(square.upperLeftCorner[0] + inchInPx, square.upperLeftCorner[1] + inchInPx));
            var path = new Path.Rectangle(rectangle);
            path.strokeColor = "red";
            path.strokeWidth = 2
            // console.log("squareID:", square.id)
            // makeCoordSineWave(square)
            //Make Lines
            if (square.line.type == "wavy") {
                
            } else {
                drawMovingLine(square.lineConnectionPoints[0], square.lineConnectionPoints[1], "blue", 1000, square.line.type === "broken")
                // var line = new Path.Line(new Point(...square.lineConnectionPoints[0]), new Point(square.lineConnectionPoints[1]))
                // line.strokeColor = "green"
                // line.strokeWidth = 3
                // if (square.line.type == "broken") line.dashArray = [10, 4];
                //if (square.line.type == "wavy") line
            }
        }
        
        
        for (let i = 0; i < newArr.length; i++) {
            // console.log("in for loop", newArr[i].upperLeftCorner)
            // console.log(newArr[i].lineConnectionPoints)
            newDrawSquare(newArr[i])
        }
        
        
        
        //i is x, j is y
        //row loop
        // for (let i = 0; i < 200; i+= inchInPx) {
        //     for (let j = 0; j < 200; j += inchInPx) {
        //         let newSquare = drawSquare([i,j], [i + inchInPx, j+inchInPx], "black")
        //         drawLines(newSquare)
        //     }
        // }
        // let newSquare = drawSquare([0,0], [96, 96], "black")
        // drawLines(newSquare)
        
        


        // Wall Drawing #146
        // All two-part combinations of blue arcs from corners and sides, 
        // and blue straight, not straight, and broken lines.
        
        //first I am going to randomly make + position all of the squares
        //then I am going to find out what has the longest continuous line
        //then I am going to find out what has the longest continuous line that does not use any of those squares
        //then once more
        //then I am going to draw the third longest
        //then random ones
        //then the second longest
        //then the first one
        
        //8 possible arcs
        //12 possible lines
        //96 total squares
        
        //1 frame is 1/100s
        
        let inchInPx = 96
        let dimensions = {x : 3, y : 3}
        let time = 0
        // function onFrame(event) {
        //     if (event.time > 5) console.log(time)
        //     else {
        //         time++
        //     // console.log(event.time)
        //     }
        // }
        function setIntervalX(callback, delay, repetitions) {
            var x = 0;
            var intervalID = window.setInterval(function () {
        
               callback();
        
               if (++x === repetitions) {
                   window.clearInterval(intervalID);
               }
            }, delay);
        }
        
        // let square = {
        //     line : {
        //         direction : "", //vertical, horizontal, upDiag, downDiag
        //         type : "" // 
        //     },
        //     arc : {
        //         center: "", //UL, RR, BR, BL, etc. tells us the center, which is all we need for an arc
        //     },
        //     id : 0, //gets assigned after shuffle
        //     upperRightCorner: //also assigned after shuffle, lets us know where to make the square
        //     arcConnectionPoints : []
        //      allConnectionPoints : [[]] // arr of coords where lines end, also assigned after shuffle
        // }
        
        
        
        let arcs = ["UL", "UU", "UR", "RR", "BR", "BB", "BL", "LL"]
        let lines = ["vertical", "horizontal", "upDiag", "downDiag"]
        let lineTypes = ["straight", "wavy", "broken"]
        
        let initialArray = []
        
        //make the initial array
        for (let i = 0; i < arcs.length; i++) {
            for (let j = 0; j < lines.length; j++) {
                for (let k = 0; k < lineTypes.length; k++) {
                    let square = {
                        line : {
                            direction : lines[j], //vertical, horizontal, upDiag, downDiag
                            type : lineTypes[k] // 
                        },
                        arc : {
                            center: arcs[i], //UL, RR, BR, BL, etc. tells us the center, which is all we need for an arc
                        },
                        id : 0, //gets assigned after shuffle
                        upperLeftCorner: [],//also assigned after shuffle, lets us know where to make the square
                        arcConnectionPoints : [],
                        lineConnectionPoints : [],
                        allConnectionPoints : [], // arr of coords where lines end, also assigned after shuffle
                        order : 0
                    }
                    initialArray.push(square)
                }
            }
        }
        
        // console.log(initialArray)
        
        //shuffle the initial array
        //stole this function
        const shuffle = (array) => { 
          for (let i = array.length - 1; i > 0; i--) { 
            const j = Math.floor(Math.random() * (i + 1)); 
            [array[i], array[j]] = [array[j], array[i]]; 
          } 
          return array; 
        }; 
        
        const newArr = shuffle(initialArray)
        // newArr.forEach(function(el) {console.log(el.arc.center)})
        
        function findArcConnectionPoints (upperLeftCorner, arcCenter) {
            if (arcCenter == "UL" || arcCenter == "BR") return [[upperLeftCorner[0] + inchInPx, upperLeftCorner[1]], [upperLeftCorner[0], upperLeftCorner[1]+inchInPx]]
            // else if (arcCenter == "BR") return [[upperLeftCorner[0] + inchInPx, upperLeftCorner[1]], [upperLeftCorner[0], upperLeftCorner[1]+inchInPx]
            else if (arcCenter ==  "UR" || arcCenter == "BL") return [[upperLeftCorner[0], upperLeftCorner[1]], [upperLeftCorner[0] + inchInPx, upperLeftCorner[1] + inchInPx]]
            // else if (arcCenter ==  "BL") return [[upperLeftCorner[0], upperLeftCorner[1]], [upperLeftCorner[0] + inchInPx, upperLeftCorner[1] + inchInPx]]
            else if (arcCenter == "UU" || arcCenter == "BB") return [[upperLeftCorner[0], upperLeftCorner[1] + (inchInPx/2)], [upperLeftCorner[0] + inchInPx, upperLeftCorner[1] + (inchInPx/2)]]
            // else if (arcCenter == "BB") return [[upperLeftCorner[0], upperLeftCorner[1] + (inchInPx/2)], [upperLeftCorner[0] + inchInPx, upperLeftCorner[1] + (inchInPx/2)]
            else if (arcCenter == "LL" || arcCenter == "RR") return [[upperLeftCorner[0] + (inchInPx/2), upperLeftCorner[1]], [upperLeftCorner[0] + (inchInPx/2), upperLeftCorner[1] + inchInPx]]
        }
        
        function findLineConnectionPoints (upperLeftCorner, direction) {
            if (direction == "vertical") return [[upperLeftCorner[0] + (inchInPx/2), upperLeftCorner[1]], [[upperLeftCorner[0] + (inchInPx/2), upperLeftCorner[1] + inchInPx]]]
            else if (direction == "horizontal") return [[upperLeftCorner[0], upperLeftCorner[1] + (inchInPx/2)], [upperLeftCorner[0] + inchInPx, upperLeftCorner[1] + (inchInPx/2)]]
            else if (direction == "upDiag") return [[upperLeftCorner[0] + inchInPx, upperLeftCorner[1]], [upperLeftCorner[0], upperLeftCorner[1]+inchInPx]]
            else if (direction == "downDiag") return [[upperLeftCorner[0], upperLeftCorner[1]], [upperLeftCorner[0] + inchInPx, upperLeftCorner[1] + inchInPx]]
        }
        
        let arrIndex = 0
        for (let i = 0; i < dimensions.y; i++) {
            for (let j = 0; j < dimensions.x; j++) {
                let upperLeftCorner = [j * inchInPx, i * inchInPx]
                let arcConnectionPoints = findArcConnectionPoints(upperLeftCorner, newArr[arrIndex].arc.center)
                let lineConnectionPoints = findLineConnectionPoints(upperLeftCorner, newArr[arrIndex].line.direction)
                newArr[arrIndex].id = arrIndex;
                newArr[arrIndex].upperLeftCorner = upperLeftCorner
                newArr[arrIndex].arcConnectionPoints = arcConnectionPoints
                newArr[arrIndex].lineConnectionPoints = lineConnectionPoints
                newArr[arrIndex].allConnectionPoints = [...arcConnectionPoints, ...lineConnectionPoints]
                // console.log(newArr[arrIndex])
                arrIndex++
            }
        }
        
        
        // for (let i = 0; i < newArr.length; i++) {
        //     drawSquare()
        // }
        
        
        // newArr.forEach(function (el) {console.log("allConnectionPoints", el.allConnectionPoints)})
        // // function makeAnyFunctionOverSpecificTime([])
        
        function makeSineWave () {
            var path = new Path()
            path.strokeColor = "green"
            // path.rotation = 45
            let done = false
            let newPath
            let direction = "downDiag"
            view.onFrame = function (event) {
                if (event.time > 1 && !done) {
                    done = true
                } else if (!done) {
                    if (newPath) newPath.remove()
                    time++
                    let zeroZero = new Point(0,0)
                    let point = new Point((Math.sin(time/4)*3+(inchInPx)), inchInPx * (time) )
                    // console.log("point before rotate", point)
                    point.rotate(45, zeroZero)
                    // console.log("point after rotate ", point)
                    // path.add(new Point(time, (Math.sin(time/10)*5+40)));
                    // console.log("this is path rotation:", path.rotation)
                    path.add(point)
                    newPath = path.clone()
                    newPath.strokeWidth = 4
                    newPath.strokeColor = "red"
                    newPath.rotate(45, new Point(inchInPx,0))
                    // if (path.rotation !== 45) path.rotation = 45
                    // path.rotate(45, zeroZero)
                    // if ((time) === 150) console.log(path.rotation)
                    
                }
            }
        }
        
        function makeSineWaveNew (startCoords, endCoords, type, order = 0) {
            //make initial path
            var path = new Path()
            path.strokeWidth = 4
            path.strokeColor = "green"
            let done 
            let diagPath
            view.onFrame = function (event) {
                //horizontal case
                
                if (type === "horizontal" && event.time * 100 < inchInPx) {
                    path.add(new Point(event.time*100, (Math.sin(event.time*100/4)*4+startCoords[1])));
                } else if (type === "vertical" && event.time * 100 < inchInPx) {
                    path.add(new Point((Math.sin(event.time*100/4)*4+startCoords[0]), event.time*100));
                } else if (type === "upDiag" && event.time * 100 < inchInPx) {
                    //we're gonna achieve this by rotating a wave that sits on the bottom
                    if (diagPath) diagPath.remove()
                    path.visible = false
                    path.add(new Point((event.time*100)*Math.sqrt(2), (Math.sin(event.time*100/4)*4+startCoords[1])));
                    diagPath = path.clone()
                    diagPath.visible = true
                    diagPath.strokeWidth = 4
                    diagPath.strokeColor = "blue"
                    diagPath.rotate(-45, new Point(...startCoords))
                } else if (type === "downDiag" && event.time * 100 < inchInPx) {
                    if (diagPath) diagPath.remove()
                    path.visible = false
                    path.add(new Point(event.time*100*Math.sqrt(2), (Math.sin(event.time*100/4)*4+startCoords[1])));
                    diagPath = path.clone()
                    diagPath.visible = true
                    diagPath.strokeWidth = 4
                    diagPath.strokeColor = "blue"
                    diagPath.rotate(45, new Point(...startCoords))
                }
                
                //vertical case
                
                
                //diag case
                let done = false
            }
        }
        // makeSineWave()
        // makeSineWaveNew([0, 48], [96, 48], "horizontal")
        // makeSineWaveNew([48, 0], [48, 96], "vertical")
        // makeSineWaveNew([0, 96], [96, 0], "upDiag")
        makeSineWaveNew([0,0], [96, 96], "downDiag")
        
        var aFrom = new Point( 0, 0 );
        var center = new Point( 0, 300 );
        var arc;
        function makeArc() {
            let done = false
            view.onFrame = function (event) {
                console.log("in on frame", (event.time % 1))
              if ( arc && !done ) {
                  arc.remove();
                }
                
              var through = aFrom.clone().rotate( ( 180 * (event.time % 1) / 4 ), center);
                var to = aFrom.clone().rotate( ( 180 * (event.time % 1 / 2) ), center);
                arc = new Path.Arc( aFrom, through, to );
                arc.strokeColor = 'black';
                if (event.time % 1 > 0.98) done = true
                }
            }
            
        
        
        // makeArc()
        
        
        function makeCoordSineWave (square) {
            console.log("in make sine", square.lineConnectionPoints, square.line.direction)
            let direction = square.line.direction 
            let startingCoords = square.lineConnectionPoints[0]
            let endingCoords = square.lineConnectionPoints[1]
        
            var path = new Path()
            path.strokeColor = "black"
            path.strokeWidth = 10
            console.log("start, end", startingCoords, endingCoords)
            let setInterval 
        }
        
        function getRandomInt(max) {
          return Math.floor(Math.random() * max) + 1;
        }
        
        
        // makeRightAngle([100,100], [300, 300], "left")
        
        function drawMovingLine(startingXY, endingXY, color, time, broken = false) {
            // console.log("in moving line", startingXY, endingXY)
            var path = new Path.Line({
                from: [startingXY[0], startingXY[1]],
                to: [startingXY[0], startingXY[1]],
                strokeColor: color,
                strokeWidth : 2
            });
            if (broken) path.dashArray = [10, 4]
            
            // console.log(path.segments[1])
            // path.dashArray = [10, 4];
            path.tween({
                'segments[1].point': {x: endingXY[0], y: endingXY[1] },
            }, time);
        }
        
        
        
        
        function newDrawSquare (square) {
            var rectangle = new Rectangle(new Point(square.upperLeftCorner), new Point(square.upperLeftCorner[0] + inchInPx, square.upperLeftCorner[1] + inchInPx));
            var path = new Path.Rectangle(rectangle);
            path.strokeColor = "red";
            path.strokeWidth = 2
            // console.log("squareID:", square.id)
            // makeCoordSineWave(square)
            //Make Lines
            if (square.line.type == "wavy") {
                
            } else {
                drawMovingLine(square.lineConnectionPoints[0], square.lineConnectionPoints[1], "blue", 1000, square.line.type === "broken")
                // var line = new Path.Line(new Point(...square.lineConnectionPoints[0]), new Point(square.lineConnectionPoints[1]))
                // line.strokeColor = "green"
                // line.strokeWidth = 3
                // if (square.line.type == "broken") line.dashArray = [10, 4];
                //if (square.line.type == "wavy") line
            }
        }
        
        
        for (let i = 0; i < newArr.length; i++) {
            // console.log("in for loop", newArr[i].upperLeftCorner)
            // console.log(newArr[i].lineConnectionPoints)
            newDrawSquare(newArr[i])
        }
        
        
        
        //i is x, j is y
        //row loop
        // for (let i = 0; i < 200; i+= inchInPx) {
        //     for (let j = 0; j < 200; j += inchInPx) {
        //         let newSquare = drawSquare([i,j], [i + inchInPx, j+inchInPx], "black")
        //         drawLines(newSquare)
        //     }
        // }
        // let newSquare = drawSquare([0,0], [96, 96], "black")
        // drawLines(newSquare)
        
        
                

        spotdl "https://open.spotify.com/playlist/37i9dQZF1DZ06evO34PI4g?si=9b5e4b193aac4ddd"
        spotdl "https://open.spotify.com/playlist/37i9dQZF1DZ06evO00jzcA?si=c2e520345b9946b8"
        spotdl "https://open.spotify.com/playlist/37i9dQZF1DZ06evO3M0Fbi?si=277b1816c72c4a06"
        spotdl "https://open.spotify.com/playlist/37i9dQZF1DZ06evNZYGncI?si=2d7ed6f4a70f46e6"
        spotdl "https://open.spotify.com/playlist/37i9dQZF1DZ06evO1H1lO8?si=6b0f670395044b63"
        spotdl "https://open.spotify.com/playlist/37i9dQZF1DZ06evO3ou9Mc?si=42dddfa66f334ffe"
        spotdl "https://open.spotify.com/album/5Qhn2FpGWmTjCuntF09j7g?si=f13d7273106f49e8"
        spotdl "https://open.spotify.com/playlist/37i9dQZF1DZ06evO1PXZsc?si=385c5e84822e40e3"
        spotdl "https://open.spotify.com/playlist/37i9dQZF1DZ06evO0yY0jC?si=26631e7c772e4e78"
        spotdl "https://open.spotify.com/album/5BGzOpea6At0Nd7tYtYZOP?si=c37e5090f8664f54"
        spotdl "https://open.spotify.com/album/0pFydyko4Iw450abXlDPpp?si=6ec80135441e456a"
        spotdl "https://open.spotify.com/playlist/4AFe96U8c9ZoeGunhjL4Wv?si=973f1586ed454177"